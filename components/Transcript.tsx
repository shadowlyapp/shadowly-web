"use client";

import { useEffect, useRef, useState } from "react";
import TranslationPopup from "@/components/TranslationPopup";
import scrollIntoView from "scroll-into-view-if-needed";

interface TranscriptLine {
  text: string;
  start: number;
  duration: number;
}

interface Props {
  transcript: TranscriptLine[];
  currentTime: number;
  onSeek: (time: number) => void;
  isAutoGenerated?: boolean;
  allowScroll?: boolean;
  notifyManualScroll?: () => void;
  targetLang: string;
  setTargetLang: (lang: string) => void;
  languages: { code: string; name: string }[];
}

export default function Transcript({
  transcript,
  currentTime,
  onSeek,
  isAutoGenerated,
  allowScroll = true,
  notifyManualScroll,
  targetLang,
  setTargetLang,
  languages,
}: Props) {
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const activeRef = useRef<HTMLParagraphElement | null>(null);
  const lastScrolledIndexRef = useRef(-1);

  const [popup, setPopup] = useState<{
    word: string;
    translation: string;
    position: { x: number; y: number };
  } | null>(null);

  const handleWordClick = async (word: string, event: React.MouseEvent) => {
    try {
      const res = await fetch("/api/translate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ word, source: "en", target: targetLang }),
      });

      const data = await res.json();
      const rect = (event.target as HTMLElement).getBoundingClientRect();

      setPopup({
        word,
        translation: data.translatedText,
        position: { x: rect.left, y: rect.bottom },
      });
    } catch (err) {
      console.error("Translation error:", err);
    }
  };

  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper || !notifyManualScroll) return;

    const pause = () => notifyManualScroll();

    wrapper.addEventListener("scroll", pause);
    wrapper.addEventListener("mousedown", pause);
    wrapper.addEventListener("touchstart", pause);

    return () => {
      wrapper.removeEventListener("scroll", pause);
      wrapper.removeEventListener("mousedown", pause);
      wrapper.removeEventListener("touchstart", pause);
    };
  }, [notifyManualScroll]);

  // Active index logic
  let activeIndex = -1;
  transcript.forEach((line, i) => {
    const previewTime = isAutoGenerated ? currentTime + 0.45 : currentTime;
    if (previewTime >= line.start && previewTime < line.start + line.duration) {
      activeIndex = i;
    }
  });

  // Smooth scroll into view if needed
  useEffect(() => {
    if (!allowScroll || activeIndex === -1 || lastScrolledIndexRef.current === activeIndex) return;
    lastScrolledIndexRef.current = activeIndex;

    const line = activeRef.current;
    const container = wrapperRef.current;

    if (line && container) {
      scrollIntoView(line, {
        behavior: "smooth",
        block: "center",
        boundary: container,
        scrollMode: "if-needed",
      });
    }
  }, [activeIndex, allowScroll]);

  return (
    <div className="w-full h-full relative">

      {/* Transcript content */}
      <div
  ref={wrapperRef}
  className="h-[50vh] overflow-y-auto space-y-1 w-full p-4 relative scroll-smooth"
>
        {transcript.map((line, index) => {
          const isActive = index === activeIndex;
          return (
            <p
              key={line.start}
              ref={isActive ? activeRef : null}
              onClick={() => onSeek(line.start)}
              className={`text-xl md:text-2xl cursor-pointer px-2 py-1 rounded-md transition-colors ${
                isActive ? "bg-yellow-200" : "hover:bg-red-100"
              }`}
            >
              {line.text.split(" ").map((word, i) => (
                <span
                  key={i}
                  onClick={(e) => {
                    e.stopPropagation();
                    handleWordClick(word, e);
                  }}
                  className="hover:underline hover:cursor-pointer"
                >
                  {word}{" "}
                </span>
              ))}
            </p>
          );
        })}

        {popup && (
          <TranslationPopup
            word={popup.word}
            translation={popup.translation}
            position={popup.position}
            onClose={() => setPopup(null)}
          />
        )}
      </div>
    </div>
  );
}