"use client";

import { useEffect, useRef, useState } from "react";
import TranslationPopup from "@/components/TranslationPopup";
import scrollIntoView from "scroll-into-view-if-needed";

interface TranscriptLine {
  text: string;
  start: number;
  duration: number;
}

interface Props {
  transcript: TranscriptLine[];
  currentTime: number;
  onSeek: (time: number) => void;
  isAutoGenerated?: boolean;
  allowScroll?: boolean;
  notifyManualScroll?: () => void;
  targetLang: string;
}

export default function Transcript({
  transcript,
  currentTime,
  onSeek,
  isAutoGenerated,
  allowScroll = true,
  notifyManualScroll,
  targetLang,
}: Props) {
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const activeRef = useRef<HTMLParagraphElement | null>(null);
  const lastScrolledIndexRef = useRef(-1);

  const [popup, setPopup] = useState<{
    word: string;
    translation: string;
    position: { x: number; y: number };
    lang: string;
    loading: boolean;
  } | null>(null);

  const fetchTranslation = async (word: string, language: string) => {
    const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/api/translate`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ word, source: "auto", target: language }),
    });

    const payload = await res
      .json()
      .catch(() => ({ error: "Unable to parse translation response" }));

    if (!res.ok) {
      throw new Error(payload?.details || payload?.error || `Translation failed with status ${res.status}`);
    }

    return (payload?.translatedText as string) || "";
  };

  const handleWordClick = async (word: string, event: React.MouseEvent) => {
    const rect = (event.target as HTMLElement).getBoundingClientRect();

    setPopup({
      word,
      translation: "",
      position: { x: rect.left, y: rect.bottom },
      lang: targetLang,
      loading: true,
    });

    try {
      const translation = await fetchTranslation(word, targetLang);
      setPopup({
        word,
        translation,
        position: { x: rect.left, y: rect.bottom },
        lang: targetLang,
        loading: false,
      });
    } catch (err) {
      console.error("Translation error:", err);
      setPopup((prev) =>
        prev && prev.word === word
          ? {
              ...prev,
              translation: "Translation unavailable at the moment.",
              loading: false,
            }
          : prev
      );
    }
  };

  useEffect(() => {
    if (!popup) return;
    if (popup.lang === targetLang) return;

    let cancelled = false;

    const refresh = async () => {
      setPopup((prev) =>
        prev
          ? {
              ...prev,
              lang: targetLang,
              loading: true,
            }
          : prev
      );

      try {
        const translation = await fetchTranslation(popup.word, targetLang);
        if (!cancelled) {
          setPopup((prev) =>
            prev
              ? {
                  ...prev,
                  translation,
                  lang: targetLang,
                  loading: false,
                }
              : prev
          );
        }
      } catch (err) {
        console.error("Translation error (language switch):", err);
        if (!cancelled) {
          setPopup((prev) =>
            prev
              ? {
                  ...prev,
                  translation: "Translation unavailable at the moment.",
                  lang: targetLang,
                  loading: false,
                }
              : prev
          );
        }
      }
    };

    refresh();

    return () => {
      cancelled = true;
    };
  }, [targetLang, popup]);

  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper || !notifyManualScroll) return;

    const pause = () => notifyManualScroll();

    wrapper.addEventListener("scroll", pause);
    wrapper.addEventListener("mousedown", pause);
    wrapper.addEventListener("touchstart", pause);

    return () => {
      wrapper.removeEventListener("scroll", pause);
      wrapper.removeEventListener("mousedown", pause);
      wrapper.removeEventListener("touchstart", pause);
    };
  }, [notifyManualScroll]);

  useEffect(() => {
    if (!popup) return;

    const handleGlobalInteraction = () => setPopup(null);

    window.addEventListener("scroll", handleGlobalInteraction, true);
    window.addEventListener("mousedown", handleGlobalInteraction, true);
    window.addEventListener("touchstart", handleGlobalInteraction, true);
    window.addEventListener("keydown", handleGlobalInteraction, true);

    return () => {
      window.removeEventListener("scroll", handleGlobalInteraction, true);
      window.removeEventListener("mousedown", handleGlobalInteraction, true);
      window.removeEventListener("touchstart", handleGlobalInteraction, true);
      window.removeEventListener("keydown", handleGlobalInteraction, true);
    };
  }, [popup]);

  // Active index logic
  let activeIndex = -1;
  transcript.forEach((line, i) => {
    const previewTime = isAutoGenerated ? currentTime + 0.45 : currentTime;
    if (previewTime >= line.start && previewTime < line.start + line.duration) {
      activeIndex = i;
    }
  });

  // Smooth scroll into view if needed
  useEffect(() => {
    if (!allowScroll || activeIndex === -1 || lastScrolledIndexRef.current === activeIndex) return;
    lastScrolledIndexRef.current = activeIndex;

    const line = activeRef.current;
    const container = wrapperRef.current;

    if (line && container) {
      scrollIntoView(line, {
        behavior: "smooth",
        block: "center",
        boundary: container,
        scrollMode: "if-needed",
      });
    }
  }, [activeIndex, allowScroll]);

  return (
    <div className="w-full h-full relative">

      {/* Transcript content */}
      <div
  ref={wrapperRef}
  className="h-[50vh] overflow-y-auto space-y-1 w-full p-4 relative scroll-smooth"
>
        {transcript.map((line, index) => {
          const isActive = index === activeIndex;
          return (
            <p
              key={line.start}
              ref={isActive ? activeRef : null}
              onClick={() => onSeek(line.start)}
              className={`text-xl md:text-2xl cursor-pointer px-2 py-1 rounded-md transition-colors ${
                isActive ? "bg-yellow-200" : "hover:bg-red-100"
              }`}
            >
              {line.text.split(" ").map((word, i) => (
                <span
                  key={i}
                  onClick={(e) => {
                    e.stopPropagation();
                    handleWordClick(word, e);
                  }}
                  className="hover:underline hover:cursor-pointer"
                >
                  {word}{" "}
                </span>
              ))}
            </p>
          );
        })}

        {popup && (
          <TranslationPopup
            word={popup.word}
            translation={popup.translation}
            loading={popup.loading}
            position={popup.position}
            onClose={() => setPopup(null)}
          />
        )}
      </div>
    </div>
  );
}
